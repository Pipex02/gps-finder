<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title id="page-title">Consulta de Históricos</title>
    <link rel="stylesheet" href="styles2.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  </head>
  <style>
    #map-container {
      height: 600px;
      width: 100%;
    }
    #map {
      width: 100%;
      height: 100%;
    }
  </style>
  <body>
    <header class="title-container">
      <a href="index.html" id="back-button" class="button">Regresar</a>
      <img src="perrito.webp" alt="perrito" class="title-image" />
      <h1 class="title">Históricos</h1>
    </header>
    <div class="content">
      <div id="map-container">
        <div id="map"></div>
      </div>
      <div class="info">
        <section class="card datetime-card">
          <h2>Fecha y hora de inicio:</h2>
          <input type="datetime-local" id="startDateTime" />
          <br /><br />
          <h2>Fecha y hora de fin:</h2>
          <input type="datetime-local" id="endDateTime" />
          <br /><br />
          <!-- Agrega este panel de control de rutas -->
          <div class="route-control-container">
            <h3>Rutas disponibles:</h3>
            <div id="route-controls"></div>
          </div>
          <div class="button-container">
            <button class="button" onclick="consultar()">Consultar</button>
            <h2>Ciudad:</h2>
            <select id="city-select">
              <option value="Barranquilla" selected>Barranquilla</option>
              <option value="Bogotá">Bogotá</option>
              <option value="Medellín">Medellín</option>
              <option value="Cali">Cali</option>
              <option value="Cartagena">Cartagena</option>
            </select>
            <br /><br />
            <input type="text" id="location-input" placeholder="Ingrese ubicación" />
            <div id="suggestions-box" class="suggestions"></div>
            <input type="number" id="radius-input" placeholder="Radio (m)" min="10" max="5000" />
            <button id="consult-button" class="button" disabled>Consultar Ubicación Específica</button>
          </div>
        </section>
      </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
      // Generar estrellas y meteoros
      function generarElementosDecorativos() {
        for (let i = 0; i < 100; i++) {
          const star = document.createElement("div");
          star.className = "star";
          star.style.top = `${Math.random() * 100}%`;
          star.style.left = `${Math.random() * 100}%`;
          document.body.appendChild(star);
        }
        for (let i = 0; i < 30; i++) {
          const meteor = document.createElement("div");
          meteor.className = "meteor";
          meteor.style.top = `${Math.random() * 100}%`;
          meteor.style.left = `${Math.random() * 100}%`;
          meteor.style.animationDelay = `${Math.random() * 5}s`;
          document.body.appendChild(meteor);
        }
      }

      // Inicializar el mapa
      const map = L.map("map").setView([10.99385, -74.79261], 12);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "© OpenStreetMap contributors",
      }).addTo(map);

      let startMarker, endMarker, locationCircle;
      let allRoutes = []; // Almacena todas las rutas
      let currentRouteIndex = 0; // Contador para identificar rutas

      // Declarar variables globales para las polilíneas
      let polyline; // Para la ruta histórica principal
      let filteredPolyline; // Para la ruta filtrada por ubicación y radio
      let filteredPolylines = []; // Para múltiples rutas (si usas varias)


      // Configuración inicial de fechas
      const startDateTime = document.getElementById("startDateTime");
      const endDateTime = document.getElementById("endDateTime");
      const consultButton = document.getElementById("consult-button");

      const minDate = new Date("2025-03-25T00:00:00");
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const endOfDay = new Date();
      endOfDay.setHours(23, 59, 0, 0);

      const toLocalISOString = (date) => {
        const offset = date.getTimezoneOffset() * 60000;
        return new Date(date.getTime() - offset).toISOString().slice(0, 16);
      };

      startDateTime.min = toLocalISOString(minDate);
      startDateTime.max = toLocalISOString(today);
      startDateTime.value = toLocalISOString(today);
      endDateTime.min = startDateTime.value;
      endDateTime.max = toLocalISOString(endOfDay);
      endDateTime.value = toLocalISOString(endOfDay);

      startDateTime.addEventListener("change", () => {
        const startValue = new Date(startDateTime.value);
        endDateTime.min = toLocalISOString(startValue);
        if (new Date(endDateTime.value) <= startValue) {
          let adjustedEnd = new Date(startValue);
          adjustedEnd.setMinutes(adjustedEnd.getMinutes() + 1);
          endDateTime.value = toLocalISOString(adjustedEnd);
        }
      });

      endDateTime.addEventListener("change", () => {
        const startValue = new Date(startDateTime.value);
        const endValue = new Date(endDateTime.value);
        if (endValue <= startValue) {
          let adjustedEnd = new Date(startValue);
          adjustedEnd.setMinutes(adjustedEnd.getMinutes() + 1);
          endDateTime.value = toLocalISOString(adjustedEnd);
        }
      });

      // Funciones de control del botón
      const inhabilitarBoton = () => (consultButton.disabled = true);
      const habilitarBoton = () => (consultButton.disabled = false);

      // Actualizar restricciones de fechas
      function actualizarRestricciones() {
        const startValue = startDateTime.value;
        if (startValue) {
          endDateTime.min = startValue;
          if (endDateTime.value && endDateTime.value < startValue) {
            endDateTime.value = startValue;
          }
        }
        inhabilitarBoton();
      }

      // Función para dividir los datos en rutas con intervalo de 30 minutos
      function splitIntoRoutes(data) {
        const routes = [];
        let currentRoute = [];
        
        data.forEach((point, index) => {
          currentRoute.push(point);
          
          // Si no es el último punto, verifica el tiempo con el próximo
          if (index < data.length - 1) {
            const currentTimestamp = new Date(point.timestamp);
            const nextTimestamp = new Date(data[index + 1].timestamp);
            
            // Calcula la diferencia en minutos
            const timeDiff = (nextTimestamp - currentTimestamp) / (1000 * 60);
            
            if (timeDiff > 30) {
              routes.push(currentRoute);
              currentRoute = [];
            }
          }
        });
        
        // Agrega la última ruta si hay datos
        if (currentRoute.length > 0) routes.push(currentRoute);
        
        return routes;
      }


      // Función para generar colores aleatorios
      function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      // Función para actualizar el panel de control de rutas
      function updateRouteControls() {
        const controlsContainer = document.getElementById('route-controls');
        controlsContainer.innerHTML = ''; // Limpiar controles anteriores

        allRoutes.forEach(route => {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = route.id;
          checkbox.checked = route.visible;
          checkbox.addEventListener('change', () => {
            toggleRouteVisibility(route.id, checkbox.checked);
          });

          const label = document.createElement('label');
          label.htmlFor = route.id;
          label.textContent = route.name;

          const visitsCount = route.data.length;
          const visitText = visitsCount === 1 ? 'visita' : 'visitas';
          label.appendChild(document.createTextNode(` (${visitsCount} ${visitText})`));

          controlsContainer.appendChild(checkbox);
          controlsContainer.appendChild(label);
          controlsContainer.appendChild(document.createElement('br'));
        });
      }

      // --- CONTROL DE VISIBILIDAD DE SEGMENTOS ---
      function updateSegmentControls() {
        const controlsContainer = document.getElementById('segment-controls');
        controlsContainer.innerHTML = '';
        segments.forEach((segment, index) => {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `segment-${index}`;
          checkbox.checked = true;
          checkbox.addEventListener('change', () => {
            toggleSegmentVisibility(index, checkbox.checked);
          });
          const label = document.createElement('label');
          label.htmlFor = `segment-${index}`;
          label.textContent = `Segmento ${index + 1}`;
          controlsContainer.appendChild(checkbox);
          controlsContainer.appendChild(label);
          controlsContainer.appendChild(document.createElement('br'));
        });
      }

      function toggleSegmentVisibility(segmentIndex, visible) {
        const polyline = filteredPolylines[segmentIndex];
        if (visible) {
          polyline.addTo(map);
        } else {
          map.removeLayer(polyline);
        }
      }

      // Función para mostrar/ocultar una ruta
      function toggleRouteVisibility(routeId, visible) {
        const route = allRoutes.find(r => r.id === routeId);
        if (route) {
          if (visible) {
            route.layer.addTo(map);
          } else {
            map.removeLayer(route.layer);
          }
          route.visible = visible;
        }
      }



      // Consultar la API de históricos
      function consultar() {
        const startInput = startDateTime.value;
        const endInput = endDateTime.value;

        if (!startInput || !endInput) {
          alert("Selecciona ambas fechas y horas.");
          return;
        }

        const startDate = new Date(startInput);
        const endDate = new Date(endInput);
        if (endDate <= startDate) {
          alert("La fecha y hora de fin deben ser posteriores a la de inicio.");
          return;
        }

        const startFormatted = `${startInput.replace("T", " ")}:00`;
        const endFormatted = `${endInput.replace("T", " ")}:00`;

        fetch(`/api/historicos?inicio=${encodeURIComponent(startFormatted)}&fin=${encodeURIComponent(endFormatted)}`)
          .then((response) => {
            if (!response.ok) throw new Error("Error en la respuesta de la API");
            return response.json();
          })
          .then((data) => {
            if (!data || data.length === 0) {
              alert("No hay datos en este rango de tiempo.");
              inhabilitarBoton();
              return;
            }

            // Ordena los datos por timestamp (si no están ordenados)
            data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Particiona los datos en rutas
            const routes = splitIntoRoutes(data);

            // Elimina rutas anteriores del mapa
            allRoutes.forEach(route => map.removeLayer(route.layer));
            
            // Reinicia el array de rutas
            allRoutes = [];

            // Crea polilíneas para cada ruta
            routes.forEach((routeData, index) => {
              const routeId = `ruta-${++currentRouteIndex}`;
              const routeName = `Ruta ${currentRouteIndex} (${new Date(routeData[0].timestamp).toLocaleString()} - ${new Date(routeData[routeData.length - 1].timestamp).toLocaleString()})`;
              const routeLatLngs = routeData.map(coord => [coord.latitud, coord.longitud]);
              
              // Crea la polilínea con un color único
              const polyline = L.polyline(routeLatLngs, {
                color: getRandomColor(),
                weight: 6,
                opacity: 0.7
              });

              // Almacena la ruta
              allRoutes.push({
                id: routeId,
                name: routeName,
                layer: polyline,
                data: routeData,
                visible: true // Por defecto, visible
              });
            });

            // Actualiza el control de rutas
            updateRouteControls();

            // Muestra la primera ruta por defecto
            if (allRoutes.length > 0) {
              allRoutes[0].layer.addTo(map);
              map.fitBounds(allRoutes[0].layer.getBounds());
            }

            habilitarBoton();
          });
      

      // Funciones de Geoapify
      async function getConfig() {
        const response = await fetch("/api/config");
        if (!response.ok) throw new Error("Error al obtener la configuración");
        const config = await response.json();
        return config;
      }

      async function fetchAutocomplete(query, city, apiKey) {
        const response = await fetch(
          `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(query)}&city=${encodeURIComponent(city)}&limit=4&apiKey=${apiKey}`
        );
        const data = await response.json();
        return data.features.map((feature) => ({
          label: feature.properties.formatted,
          lat: feature.properties.lat,
          lon: feature.properties.lon,
        }));
      }

      async function fetchCoordinates(address, city, apiKey) {
        const response = await fetch(
          `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(address)}&city=${encodeURIComponent(city)}&limit=1&apiKey=${apiKey}`
        );
        const data = await response.json();
        if (data.features.length > 0) {
          return {
            lat: data.features[0].properties.lat,
            lon: data.features[0].properties.lon,
          };
        }
        return null;
      }

      // Nueva función para consultar ubicaciones dentro del radio
      async function consultarUbicacionEspecifica() {
        const address = document.getElementById("location-input").value;
        const city = document.getElementById("city-select").value;
        const radius = document.getElementById("radius-input").value;
        const config = await getConfig();
        const apiKey = config.geoapifyApiKey;

        if (!address || !radius) {
          alert("Por favor, ingrese una ubicación y un radio.");
          return;
        }

        const coords = await fetchCoordinates(address, city, apiKey);
        if (!coords) {
          alert("Ubicación no encontrada.");
          return;
        }

        const { lat, lon } = coords;
        const startInput = startDateTime.value;
        const endInput = endDateTime.value;

        if (!startInput || !endInput) {
          alert("Selecciona ambas fechas y horas.");
          return;
        }

        const startFormatted = `${startInput.replace("T", " ")}:00`;
        const endFormatted = `${endInput.replace("T", " ")}:00`;
        let filteredPolylines = [];

        fetch(`/api/lugar?latitud=${lat}&longitud=${lon}&radio=${radius}&inicio=${encodeURIComponent(startFormatted)}&fin=${encodeURIComponent(endFormatted)}`)
          .then((response) => {
            if (!response.ok) throw new Error("Error en la respuesta de la API");
            return response.json();
          })
          .then((data) => {
            if (!data || data.length === 0) {
              alert("No hay datos en este rango de tiempo dentro del radio seleccionado.");
              return;
            }

            // Limpiar polilíneas anteriores
            filteredPolylines.forEach(polyline => map.removeLayer(polyline));
            filteredPolylines = [];

            // Dibujar cada ruta con un color distinto
            const colors = ['#32CD32', '#FFD700', '#4B0082', '#FF0000', '#00FF00', '#0000FF'];
            data.forEach((route, index) => {
              const allPoints = data.flatMap(route => route); // Combinar todos los puntos
              const segments = splitInto10SecondSegments(allPoints);
            
              // --- DIBUJAR CADA SEGMENTO CON COLOR ÚNICO ---
              const colorPalette = ['#FF0000', '#00FF00', '#0000FF', '#FFA500', '#8A2BE2', '#FFFF00', '#008000', '#000080'];
              segments.forEach((segment, index) => {
                const coordinates = segment.map(p => [p.latitud, p.longitud]);
                const color = colorPalette[index % colorPalette.length];
                const polyline = L.polyline(coordinates, {
                  color: color,
                  weight: 6,
                  opacity: 0.8
                }).addTo(map);
                filteredPolylines.push(polyline);
              }); // Cierre del bucle interno
            
            }); // Cierre del bucle externo
            
            // --- ACTUALIZAR CONTROLES DE SEGMENTOS ---
            updateSegmentControls();
            
            // Actualiza el control de rutas
            updateRouteControls();
            
            // Muestra la primera ruta por defecto
            if (allRoutes.length > 0) {
              allRoutes[0].layer.addTo(map);
              map.fitBounds(allRoutes[0].layer.getBounds());
            }
          })
          .catch((error) => {
            console.error("Error al consultar ubicación específica:", error);
          });
        
      }

      // Inicialización
      document.addEventListener("DOMContentLoaded", async () => {
        try {
          const config = await getConfig();
          const apiKey = config.geoapifyApiKey;

          // Actualizar el título de la página con el valor de APP_TITLE
          if (config.pageTitle) {
            document.getElementById("page-title").textContent = config.pageTitle || "Consulta de Históricos";
          }

          const locationInput = document.getElementById("location-input");
          const suggestionsBox = document.getElementById("suggestions-box");
          const citySelect = document.getElementById("city-select");
          const radiusInput = document.getElementById("radius-input");

          // Autocompletado
          locationInput.addEventListener("input", async () => {
            const query = locationInput.value;
            const city = citySelect.value;
            if (query.length < 7) {
              suggestionsBox.style.display = "none";
              return;
            }

            const suggestions = await fetchAutocomplete(query, city, apiKey);
            suggestionsBox.innerHTML = "";
            suggestions.forEach((suggestion, index) => {
              const div = document.createElement("div");
              div.className = "suggestion-item";
              div.textContent = suggestion.label;
              div.dataset.index = index;
              div.addEventListener("click", () => {
                locationInput.value = suggestion.label;
                suggestionsBox.style.display = "none";
              });
              suggestionsBox.appendChild(div);
            });
            suggestionsBox.style.display = suggestions.length > 0 ? "block" : "none";
          });

          locationInput.addEventListener("blur", () => {
            setTimeout(() => (suggestionsBox.style.display = "none"), 200);
          });

          // Evento para consultar ubicación específica
          consultButton.addEventListener("click", consultarUbicacionEspecifica);

          generarElementosDecorativos();
          startDateTime.addEventListener("input", actualizarRestricciones);
          endDateTime.addEventListener("input", actualizarRestricciones);
          inhabilitarBoton();
        } catch (error) {
          console.error("Error al cargar la configuración:", error);
        }
      });

      // --- NUEVA FUNCIÓN PARA PROCESAR DATOS EN SEGMENTOS DE 10 SEGUNDOS ---
      function splitInto10SecondSegments(data) {
        const segments = [];
        let currentSegment = [];
        let prevTimestamp = null;

        data.forEach((point, index) => {
          if (index === 0) {
            currentSegment = [point];
            prevTimestamp = new Date(point.timestamp);
            return;
          }

          const currentTs = new Date(point.timestamp);
          const timeDiff = currentTs - prevTimestamp;

          if (timeDiff > 10_000) { // 10 segundos en milisegundos
            segments.push(currentSegment);
            currentSegment = [point];
          } else {
            currentSegment.push(point);
          }
          prevTimestamp = currentTs;
        });

        if (currentSegment.length > 0) {
          segments.push(currentSegment);
        }

        return segments;
      }
      
    </script>
  </body>
</html>